---
phase: 06-backend-cleanup-refactoring
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - backend/records/views.py
  - backend/config/permissions.py
autonomous: true
requirements:
  - REFAC-01
  - REFAC-02
  - REFAC-03
  - REFAC-04
  - REFAC-05
must_haves:
  truths:
    - "Multi-assignment creation uses bulk_create for MailAssignment rows instead of individual create calls"
    - "DAG section officer lookup in get_queryset uses a single subquery instead of two sequential queries"
    - "_assigned_mail_ids_for_user result is cached per request to avoid repeated DB hits"
    - "Touched records query in permissions.py is DRY with request-level caching (already partially done)"
    - "_human_readable_size exists in exactly one place as a static method on RecordAttachment"
  artifacts:
    - path: "backend/records/views.py"
      provides: "Optimized views with bulk_create, subquery, and per-request caching"
      contains: "bulk_create"
    - path: "backend/config/permissions.py"
      provides: "DRY touched records helper with request-level cache"
      contains: "_touched_record_ids_cache"
  key_links:
    - from: "backend/records/views.py"
      to: "backend/records/models.py"
      via: "MailAssignment.objects.bulk_create"
      pattern: "bulk_create"
    - from: "backend/config/permissions.py"
      to: "backend/records/views.py"
      via: "Both use request-level caching for touched records"
      pattern: "_touched_record_ids_cache"
---

<objective>
Optimize backend queries and eliminate redundant patterns in views and permissions.

Purpose: Reduce database round-trips in common operations (mail creation, DAG list queries, permission checks) and DRY up repeated query patterns. These optimizations directly benefit page load times for DAG users and mail creation throughput.

Output: Refactored views.py with bulk_create, subqueries, and per-request caching. Cleaner permissions.py with DRY touched-records helper.
</objective>

<execution_context>
@C:/Users/vaish/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/vaish/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-backend-cleanup-refactoring/06-01-SUMMARY.md
@backend/records/views.py
@backend/config/permissions.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Bulk-create assignments and audit trails in mail creation and multi-assign</name>
  <files>
    backend/records/views.py
  </files>
  <action>
REFAC-01: In the `create` method of MailRecordViewSet (around lines 354-381):

Replace the loop that creates MailAssignment objects one at a time:
```python
for assignee in assignees:
    MailAssignment.objects.create(
        mail_record=mail_record,
        assigned_to=assignee,
        assigned_by=user,
        assignment_remarks=initial_instructions,
        status='Active'
    )
```

With bulk_create:
```python
assignment_objects = [
    MailAssignment(
        mail_record=mail_record,
        assigned_to=assignee,
        assigned_by=user,
        assignment_remarks=initial_instructions,
        status='Active'
    )
    for assignee in assignees
]
MailAssignment.objects.bulk_create(assignment_objects)
```

Also replace the two separate AuditTrail.objects.create calls (CREATE + ASSIGN) with a single bulk_create:
```python
assignee_names = [a.full_name for a in assignees]
action_type = 'MULTI_ASSIGN' if len(assignees) > 1 else 'ASSIGN'
audit_entries = [
    AuditTrail(
        mail_record=mail_record,
        action='CREATE',
        performed_by=user,
        new_value={'sl_no': mail_record.sl_no, 'status': 'Assigned'},
        remarks=f'Created with initial instructions: {initial_instructions[:100]}'
    ),
    AuditTrail(
        mail_record=mail_record,
        action=action_type,
        performed_by=user,
        new_value={'assigned_to': assignee_names},
        remarks=f"Assigned to {len(assignees)} officer(s): {', '.join(assignee_names)}"
    ),
]
AuditTrail.objects.bulk_create(audit_entries)
```

In the `multi_assign` method (around lines 773-793): The loop uses get_or_create which cannot be bulk-created (needs existence check). Leave this loop as-is but bulk_create the AuditTrail entries. Collect audit entries in a list during the loop and call `AuditTrail.objects.bulk_create(audit_entries)` after the loop instead of creating them individually inside it:
```python
created_assignments = []
audit_entries = []
for u in users:
    assignment, created = MailAssignment.objects.get_or_create(
        mail_record=mail_record,
        assigned_to=u,
        status='Active',
        defaults={
            'assigned_by': user,
            'assignment_remarks': remarks
        }
    )
    if created:
        created_assignments.append(assignment)
        audit_entries.append(AuditTrail(
            mail_record=mail_record,
            action='MULTI_ASSIGN',
            performed_by=user,
            new_value={'assigned_to': u.full_name},
            remarks=f"Assigned to {u.full_name}: {remarks}"
        ))

if audit_entries:
    AuditTrail.objects.bulk_create(audit_entries)
```

REFAC-03: Add per-request caching for `_assigned_mail_ids_for_user`. Modify the method to accept a request parameter and cache the result:
```python
def _assigned_mail_ids_for_user(self, user, request=None):
    cache_attr = '_assigned_mail_ids_cache'
    if request and hasattr(request, cache_attr):
        return getattr(request, cache_attr)
    result = list(MailAssignment.objects.filter(
        Q(assigned_to=user) | Q(reassigned_to=user),
        status='Active'
    ).values_list('mail_record_id', flat=True).distinct())
    if request:
        setattr(request, cache_attr, result)
    return result
```

Update all call sites of `_assigned_mail_ids_for_user` to pass `self.request`:
- In `_apply_status_scope_filter` (line 57): `self._assigned_mail_ids_for_user(user, getattr(self, 'request', None))`
- In `get_queryset` DAG block (line 195): `self._assigned_mail_ids_for_user(user, self.request)`
- In `get_queryset` SrAO/AAO block (line 219): `self._assigned_mail_ids_for_user(user, self.request)`
- In `get_queryset` clerk block (line 230): `self._assigned_mail_ids_for_user(user, self.request)`
  </action>
  <verify>
Run `cd backend && python manage.py check` to verify no errors. Grep for `bulk_create` in views.py to confirm it appears in create and multi_assign methods. Grep for `_assigned_mail_ids_cache` to confirm caching is in place.
  </verify>
  <done>
Mail creation uses bulk_create for both MailAssignment and AuditTrail rows. Multi-assign uses bulk_create for AuditTrail. _assigned_mail_ids_for_user caches its result per request.
  </done>
</task>

<task type="auto">
  <name>Task 2: Optimize DAG queries and DRY up touched-records in permissions</name>
  <files>
    backend/records/views.py
    backend/config/permissions.py
  </files>
  <action>
REFAC-02: In `get_queryset` DAG block (around lines 191-213), collapse the two sequential queries for section officers into one using a Subquery or combined Q filter. Currently:
```python
section_officer_ids = User.objects.filter(
    subsection__section_id__in=dag_section_ids, is_active=True
).values_list('id', flat=True)
cross_section_mail_ids = MailAssignment.objects.filter(
    assigned_to_id__in=section_officer_ids,
    status__in=['Active', 'Completed']
).values_list('mail_record_id', flat=True).distinct()
```

Replace with a single subquery using Django's Subquery or a direct join:
```python
cross_section_mail_ids = MailAssignment.objects.filter(
    assigned_to__subsection__section_id__in=dag_section_ids,
    assigned_to__is_active=True,
    status__in=['Active', 'Completed']
).values_list('mail_record_id', flat=True).distinct()
```
This eliminates the intermediate `section_officer_ids` query by using Django ORM's join capability. Remove the `section_officer_ids` variable entirely.

Also remove the `User` import from the top of the DAG block since it was only needed for section_officer_ids (check if User is imported elsewhere in the file first — it IS imported at the top for other uses, so just remove the intermediate variable).

REFAC-04: In config/permissions.py, the touched-records caching is already partially implemented (lines 115-121 and 135-142 use `request._touched_record_ids_cache`). Extract this into a helper method on the permission class to DRY it up:

```python
def _get_touched_record_ids(self, user, request):
    """Get mail record IDs this user has touched, cached per request."""
    cache_attr = '_touched_record_ids_cache'
    cached = getattr(request, cache_attr, None)
    if cached is not None:
        return cached
    from audit.models import AuditTrail
    touched_ids = set(AuditTrail.objects.filter(
        performed_by=user
    ).values_list('mail_record_id', flat=True))
    setattr(request, cache_attr, touched_ids)
    return touched_ids
```

Add this method to the `MailRecordPermission` class. Then replace both inline usages in `_can_view_mail`:

In the DAG block (around line 115-122), replace:
```python
touched_ids = getattr(request, '_touched_record_ids_cache', None)
if touched_ids is None:
    from audit.models import AuditTrail
    touched_ids = set(AuditTrail.objects.filter(
        performed_by=user
    ).values_list('mail_record_id', flat=True))
    request._touched_record_ids_cache = touched_ids
return obj.id in touched_ids
```
With:
```python
return obj.id in self._get_touched_record_ids(user, request)
```

In the SrAO/AAO block (around line 135-142), make the same replacement.

REFAC-05 was already handled in Plan 01 Task 1 (MailRecord.get_attachment_metadata now calls RecordAttachment._human_readable_size instead of inline logic). Verify it's in place — no additional work needed here.
  </action>
  <verify>
Run `cd backend && python manage.py check` to verify no errors. Run `cd backend && python -c "import django; import os; os.environ['DJANGO_SETTINGS_MODULE']='config.settings'; django.setup(); from records.views import MailRecordViewSet; print('Views OK')"` to confirm imports work. Grep for `section_officer_ids` in views.py to confirm it's gone. Grep for `_get_touched_record_ids` in permissions.py to confirm the helper exists.
  </verify>
  <done>
DAG section officer lookup uses one query (joined through assigned_to__subsection__section_id). Touched-records logic in permissions.py is DRY with a single _get_touched_record_ids helper method. _assigned_mail_ids_for_user is cached per request. _human_readable_size exists only as RecordAttachment static method.
  </done>
</task>

</tasks>

<verification>
1. `cd backend && python manage.py check` passes
2. `grep -n "bulk_create" backend/records/views.py` shows bulk_create in create() and multi_assign() methods
3. `grep -n "section_officer_ids" backend/records/views.py` returns zero results
4. `grep -n "_get_touched_record_ids" backend/config/permissions.py` returns at least 3 results (1 definition + 2 calls)
5. `grep -n "_assigned_mail_ids_cache" backend/records/views.py` returns results confirming per-request caching
6. `grep -c "_human_readable_size" backend/records/models.py` returns exactly 2 (1 definition in RecordAttachment + 1 call in MailRecord.get_attachment_metadata)
</verification>

<success_criteria>
- bulk_create used for MailAssignment and AuditTrail in mail creation
- DAG section officer query collapsed from 2 queries to 1 subquery
- _assigned_mail_ids_for_user cached per request
- Touched-records query in permissions.py DRY with helper method
- All Django checks pass, no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/06-backend-cleanup-refactoring/06-02-SUMMARY.md`
</output>
