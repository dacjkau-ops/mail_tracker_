---
phase: 02-role-system-backend-updates
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/users/models.py
  - backend/users/migrations/0007_add_auditor_clerk_roles.py
  - backend/records/models.py
  - backend/records/migrations/0012_action_required_free_text.py
autonomous: true
requirements:
  - ROLE-01
  - WORKFLOW-04
  - WORKFLOW-05

must_haves:
  truths:
    - "User.ROLE_CHOICES contains ('auditor', 'Auditor') and ('clerk', 'Clerk') entries"
    - "User.auditor_subsections is a ManyToManyField referencing sections.Subsection"
    - "User.is_auditor() returns True for a user with role='auditor'"
    - "User.is_clerk() returns True for a user with role='clerk'"
    - "MailRecord.action_required has max_length=500 and blank=True with no choices constraint"
    - "Existing action_required data ('Review', 'Approve', etc.) is preserved as-is"
  artifacts:
    - path: "backend/users/models.py"
      provides: "Updated User model with auditor/clerk roles and auditor_subsections M2M"
      contains: "auditor.*clerk"
    - path: "backend/users/migrations/0007_add_auditor_clerk_roles.py"
      provides: "Migration for role choices + auditor_subsections field"
    - path: "backend/records/models.py"
      provides: "action_required as free-text CharField(500) with blank=True"
    - path: "backend/records/migrations/0012_action_required_free_text.py"
      provides: "Migration for action_required field change"
  key_links:
    - from: "backend/users/models.py User.ROLE_CHOICES"
      to: "auditor and clerk role strings"
      via: "CharField choices"
      pattern: "auditor.*clerk|clerk.*auditor"
    - from: "backend/users/models.py User.auditor_subsections"
      to: "sections.Subsection"
      via: "ManyToManyField"
      pattern: "auditor_subsections.*ManyToManyField|ManyToManyField.*Subsection"
    - from: "backend/records/models.py MailRecord.action_required"
      to: "CharField max_length=500 blank=True"
      via: "field definition"
      pattern: "action_required.*500"
---

<objective>
Expand the User model with two new roles (auditor, clerk) and add auditor subsection configuration. Convert action_required from a constrained dropdown to a free-text optional field.

Purpose: Establishes the data model foundation that permissions and visibility logic in Plan 02 and Plan 03 will depend on. All role-based routing requires these roles to exist first.
Output: Updated User model with migration, updated MailRecord.action_required field with migration.
</objective>

<execution_context>
@C:/Users/vaish/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/vaish/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@backend/users/models.py
@backend/records/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add auditor and clerk roles to User model + auditor_subsections M2M</name>
  <files>backend/users/models.py</files>
  <action>
Make two targeted changes to `backend/users/models.py`:

**Change 1 — ROLE_CHOICES:** Add two new entries to ROLE_CHOICES, keeping all existing choices intact:
```python
ROLE_CHOICES = [
    ('AG', 'Accountant General'),
    ('DAG', 'Deputy Accountant General'),
    ('SrAO', 'Senior Audit Officer'),
    ('AAO', 'Assistant Audit Officer'),
    ('auditor', 'Auditor'),
    ('clerk', 'Clerk'),
]
```

**Change 2 — auditor_subsections M2M field:** Add a new ManyToManyField on the User model (after the existing `subsection` ForeignKey field):
```python
auditor_subsections = models.ManyToManyField(
    Subsection,
    related_name='auditors',
    blank=True,
    help_text="Subsections visible to this auditor (configured by admin). Only used when role='auditor'."
)
```

**Change 3 — Update helper methods:** Extend the existing role helper methods to handle new roles:
- `is_staff_officer()`: Keep returning `role in ['SrAO', 'AAO']` — auditor and clerk are NOT staff officers, they have separate logic
- Add `is_auditor()` method: `return self.role == 'auditor'`
- Add `is_clerk()` method: `return self.role == 'clerk'`

**Change 4 — Update get_sections_list():** The existing method has an `elif self.subsection:` branch for SrAO/AAO. Add handling for clerk and auditor:
```python
def get_sections_list(self):
    if self.role == 'AG':
        return Section.objects.all()
    elif self.role == 'DAG':
        return self.sections.all()
    elif self.role == 'auditor':
        # Return sections that contain any of the auditor's configured subsections
        subsection_ids = self.auditor_subsections.values_list('id', flat=True)
        return Section.objects.filter(subsections__id__in=subsection_ids).distinct()
    elif self.subsection:
        # SrAO, AAO, clerk — subsection FK
        return Section.objects.filter(id=self.subsection.section_id)
    return Section.objects.none()
```

**Change 5 — Update get_dag():** The existing `get_dag()` handles SrAO/AAO via `else:`. Add explicit handling for auditor so they return the SrAO/AAO in their subsection (not the DAG), since auditor escalates only to SrAO/AAO:
```python
def get_dag(self):
    if self.role == 'AG':
        return self
    elif self.role == 'DAG':
        return User.get_primary_ag()
    elif self.role == 'auditor':
        # Auditor's immediate superior is an SrAO/AAO in any of their configured subsections
        # Return first active SrAO/AAO in their primary auditor subsection (first configured)
        first_sub = self.auditor_subsections.first()
        if first_sub:
            return User.objects.filter(
                role__in=['SrAO', 'AAO'],
                subsection=first_sub,
                is_active=True
            ).order_by('id').first()
        return None
    else:  # SrAO, AAO, clerk
        if self.subsection and self.subsection.section:
            if self.subsection.section.directly_under_ag:
                return User.get_primary_ag()
            return User.objects.filter(
                role='DAG',
                sections=self.subsection.section,
                is_active=True
            ).order_by('id').first()
    return None
```

**Change 6 — Update save() method:** The existing `save()` resets `is_primary_ag` for non-AG users. Extend to also ensure new roles don't carry stale section data:
```python
def save(self, *args, **kwargs):
    if self.role != 'AG':
        self.is_primary_ag = False
    super().save(*args, **kwargs)
```
(No change needed — logic is already role-neutral.)

Do NOT change: the `sections` M2M field (for DAG), the `subsection` FK field (reused for clerk/SrAO/AAO), the `is_primary_ag` constraint, or the unique_primary_ag_user constraint.
  </action>
  <verify>
```bash
cd D:/Office/2026/Mail_Tracker/backend && python manage.py check --deploy 2>&1 | head -30
```
Expected: "System check identified no issues (0 silenced)." or only deployment warnings (HSTS, SECURE_SSL_REDIRECT), no errors about models.

Also run behavioral assertions to confirm new methods work correctly:
```bash
cd D:/Office/2026/Mail_Tracker/backend && python -c "
import django; django.setup()
from users.models import User

# Verify ROLE_CHOICES contains new entries
roles = dict(User.ROLE_CHOICES)
assert 'auditor' in roles, 'auditor missing from ROLE_CHOICES'
assert 'clerk' in roles, 'clerk missing from ROLE_CHOICES'
print('ROLE_CHOICES OK:', list(roles.keys()))

# Verify auditor_subsections M2M field exists
field = User._meta.get_field('auditor_subsections')
print('auditor_subsections field type:', type(field).__name__)

# Verify is_auditor() and is_clerk() methods exist and behave correctly
u = User()
u.role = 'auditor'
assert u.is_auditor() == True, 'is_auditor() should return True for role=auditor'
assert u.is_clerk() == False, 'is_clerk() should return False for role=auditor'
u.role = 'clerk'
assert u.is_clerk() == True, 'is_clerk() should return True for role=clerk'
assert u.is_auditor() == False, 'is_auditor() should return False for role=clerk'
u.role = 'AG'
assert u.is_auditor() == False, 'is_auditor() should return False for role=AG'
print('is_auditor() and is_clerk() assertions pass')

# Verify get_dag() for auditor with no subsections returns None (no crash)
u.role = 'auditor'
# Simulate: auditor with no auditor_subsections configured
# Cannot directly test M2M without DB save, but confirm method exists
assert hasattr(u, 'get_dag'), 'get_dag() method missing'
print('get_dag() method exists on User')
print('All behavioral assertions passed')
"
```
Expected: All assertions pass without AssertionError.
  </verify>
  <done>
User model has 'auditor' and 'clerk' in ROLE_CHOICES, auditor_subsections ManyToManyField exists referencing sections.Subsection, is_auditor() returns True for role='auditor', is_clerk() returns True for role='clerk', get_sections_list() handles auditor role, get_dag() handles auditor role returning SrAO/AAO superior. Behavioral assertions confirm correctness without needing a saved DB record.
  </done>
</task>

<task type="auto">
  <name>Task 2: Convert action_required to free-text optional field</name>
  <files>backend/records/models.py</files>
  <action>
In `backend/records/models.py`, make two targeted changes to the `MailRecord` model:

**Change 1 — Remove ACTION_CHOICES constant and update field definition:**

Remove the `ACTION_CHOICES` class variable entirely:
```python
# DELETE this entire block:
ACTION_CHOICES = [
    ('Review', 'Review'),
    ('Approve', 'Approve'),
    ('Process', 'Process'),
    ('File', 'File'),
    ('Reply', 'Reply'),
    ('Other', 'Other'),
]
```

Change the `action_required` field from:
```python
action_required = models.CharField(max_length=50, choices=ACTION_CHOICES)
```
To:
```python
action_required = models.CharField(
    max_length=500,
    blank=True,
    help_text="What action is required on this mail (free text, optional, max 500 chars)"
)
```

Keep `action_required_other` field as-is (do not remove it — it may have data and we are not cleaning up legacy fields in this phase).

**Why this approach:** Per user decision — "Make this leaner not bulkier — remove dropdown cruft entirely." Existing values like 'Review', 'Approve', etc. remain valid as free-text strings. No data migration required — existing values are shorter than 500 chars and blank=True allows empty strings.
  </action>
  <verify>
```bash
cd D:/Office/2026/Mail_Tracker/backend && python manage.py check 2>&1
```
Expected: No errors. Warnings about `action_required` or `action_required_other` being unused are acceptable.
  </verify>
  <done>
action_required field is CharField(max_length=500, blank=True) with no choices constraint. ACTION_CHOICES constant removed from MailRecord. action_required_other field still present unchanged. python manage.py check shows no errors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Generate and apply migrations for both model changes</name>
  <files>
    backend/users/migrations/0007_add_auditor_clerk_roles.py
    backend/records/migrations/0012_action_required_free_text.py
  </files>
  <action>
Generate migrations for both model changes, then verify they apply cleanly.

**Step 1 — Generate migrations:**
```bash
cd D:/Office/2026/Mail_Tracker/backend
python manage.py makemigrations users --name="add_auditor_clerk_roles"
python manage.py makemigrations records --name="action_required_free_text"
```

**Step 2 — Review generated migrations:** The users migration should contain:
- AlterField on `role` to update choices list
- AddField for `auditor_subsections` ManyToManyField

The records migration should contain:
- AlterField on `action_required` changing max_length from 50 to 500 and removing choices

**Step 3 — Apply migrations:**
```bash
python manage.py migrate
```

**Step 4 — Verify:**
```bash
python manage.py migrate --check
```
Expected: Exit 0 (all migrations applied).

If Django generates a migration for `action_required_other` or any unrelated field, that is acceptable — do not suppress it.

Note: Django generates a migration for `choices` changes even though choices are only enforced at the Python level (not at the database level). This is expected behavior.
  </action>
  <verify>
```bash
cd D:/Office/2026/Mail_Tracker/backend && python manage.py migrate --check && python manage.py check
```
Expected: Both commands exit 0 with no errors.
  </verify>
  <done>
Migration files exist at backend/users/migrations/0007_add_auditor_clerk_roles.py and backend/records/migrations/0012_action_required_free_text.py. `python manage.py migrate` applies both without errors. `python manage.py migrate --check` exits 0.
  </done>
</task>

</tasks>

<verification>
Run full check sequence:
```bash
cd D:/Office/2026/Mail_Tracker/backend
python manage.py check
python manage.py migrate --check
python -c "
import django; django.setup()
from users.models import User

roles = dict(User.ROLE_CHOICES)
print('ROLE_CHOICES:', list(roles.keys()))
assert 'auditor' in roles and 'clerk' in roles, 'Missing auditor or clerk'

field = User._meta.get_field('auditor_subsections')
print('auditor_subsections field type:', type(field).__name__)

u = User()
u.role = 'auditor'
assert u.is_auditor() == True
u.role = 'clerk'
assert u.is_clerk() == True
print('Role helper methods: OK')

from records.models import MailRecord
f = MailRecord._meta.get_field('action_required')
print('action_required max_length:', f.max_length)
print('action_required blank:', f.blank)
print('action_required choices:', f.choices)
assert f.max_length == 500 and f.blank == True and not f.choices
print('All assertions passed')
"
```

Expected:
- check: no issues
- migrate --check: exit 0
- auditor/clerk in ROLE_CHOICES
- auditor_subsections field exists as ManyToManyField
- is_auditor and is_clerk assertions pass
- action_required max_length=500, blank=True, choices=[] or None
</verification>

<success_criteria>
- User.ROLE_CHOICES includes ('auditor', 'Auditor') and ('clerk', 'Clerk')
- User.auditor_subsections is a ManyToManyField to Subsection
- User.is_auditor() returns True for role='auditor', False otherwise
- User.is_clerk() returns True for role='clerk', False otherwise
- MailRecord.action_required is CharField(max_length=500, blank=True) with no choices
- Both migrations apply cleanly
- No existing data affected (existing action_required values remain as-is)
- python manage.py check exits 0
</success_criteria>

<output>
After completion, create `.planning/phases/02-role-system-backend-updates/02-01-SUMMARY.md`
</output>
