---
phase: 02-role-system-backend-updates
plan: "03"
type: execute
wave: 2
depends_on:
  - "02-01"
files_modified:
  - backend/records/serializers.py
  - backend/records/views.py
  - backend/users/serializers.py
autonomous: true
requirements:
  - ROLE-07
  - BACKEND-03

must_haves:
  truths:
    - "SrAO/AAO users can create mail records scoped to their own subsection"
    - "Clerk users can create mail records scoped to their own subsection"
    - "Auditor users can create mail records scoped to their configured subsections"
    - "When any non-AG/DAG creates a mail, assignee dropdown is limited to their own subsection"
    - "MailRecord list and detail responses include attachment metadata (has_attachment, attachment_id, original_filename, file_size_human)"
    - "Serializer includes attachment_metadata as a read-only computed field"
  artifacts:
    - path: "backend/records/serializers.py"
      provides: "Create serializer validates scoped creation, list/detail include attachment_metadata"
      contains: "attachment_metadata|has_attachment"
    - path: "backend/records/views.py"
      provides: "create() allows non-AG roles with subsection scoping"
      contains: "subsection.*clerk.*SrAO|SrAO.*AAO.*auditor"
    - path: "backend/users/serializers.py"
      provides: "UserMinimalSerializer handles auditor and clerk roles for dropdown display"
      contains: "auditor.*clerk|clerk.*auditor"
  key_links:
    - from: "backend/records/views.py create()"
      to: "role-based section/subsection scoping"
      via: "user.role branching on create"
      pattern: "role.*SrAO|role.*clerk|role.*auditor"
    - from: "backend/records/serializers.py MailRecordListSerializer"
      to: "attachment_metadata field"
      via: "SerializerMethodField"
      pattern: "attachment_metadata|get_attachment_metadata"
    - from: "backend/records/serializers.py MailRecordCreateSerializer"
      to: "subsection-scoped validation"
      via: "validate() method"
      pattern: "subsection.*role|role.*subsection"
---

<objective>
Enable all authenticated roles to create mail records with appropriate scoping, and expose PDF attachment metadata on list/detail serializers.

Purpose: Plan 02 handles visibility; this plan handles creation rights and serializer completeness. These are independent of each other (no shared files with Plan 02) so they run in the same wave.
Output: Updated create() view logic, role-aware CreateSerializer validation, attachment_metadata on list/detail serializers, updated UserMinimalSerializer for new roles.
</objective>

<execution_context>
@C:/Users/vaish/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/vaish/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-role-system-backend-updates/02-01-SUMMARY.md
@backend/records/serializers.py
@backend/records/views.py
@backend/users/serializers.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add attachment_metadata to list and detail serializers</name>
  <files>backend/records/serializers.py</files>
  <action>
Add `attachment_metadata` as a read-only SerializerMethodField to both `MailRecordListSerializer` and `MailRecordDetailSerializer`.

**MailRecordListSerializer:**

Add to class body (alongside `time_in_stage`, `is_overdue` etc.):
```python
attachment_metadata = serializers.SerializerMethodField()
```

Add method:
```python
def get_attachment_metadata(self, obj):
    return obj.get_attachment_metadata()
```

Add `'attachment_metadata'` to the `fields` list in `Meta`.

**MailRecordDetailSerializer:**

Add to class body:
```python
attachment_metadata = serializers.SerializerMethodField()
```

Add method:
```python
def get_attachment_metadata(self, obj):
    return obj.get_attachment_metadata()
```

`MailRecordDetailSerializer` uses `fields = '__all__'`, so the new SerializerMethodField will NOT be included automatically — it must be explicitly listed OR the Meta must be switched. Switch the Meta to list fields explicitly OR use the simplest approach: add the field to the serializer class and note that SerializerMethodFields declared on the class ARE included in `__all__` when using DRF (DRF's `__all__` for ModelSerializer includes declared fields). This is correct DRF behavior.

Actually, with DRF ModelSerializer and `fields = '__all__'`: declared fields on the class body (like SerializerMethodField) are automatically included. Verify this is the case — if not, add `attachment_metadata` explicitly to the fields list.

**MailRecordCreateSerializer validation update for action_required:**

The `validate()` method currently checks:
```python
if data.get('action_required') == 'Other' and not data.get('action_required_other'):
    raise serializers.ValidationError(...)
```

Remove this entire block — `action_required` is now free text with no 'Other' sentinel value. Keep all other validation unchanged.

Also update the `action_required` field in the `Meta.fields` list — it remains in the list but now the model field has no choices constraint, so no additional serializer-level changes are needed.
  </action>
  <verify>
```bash
cd D:/Office/2026/Mail_Tracker/backend && python -c "
import django; django.setup()
from records.serializers import MailRecordListSerializer, MailRecordDetailSerializer
# Check attachment_metadata is declared
print('List has attachment_metadata:', 'attachment_metadata' in MailRecordListSerializer().fields)
print('Detail has attachment_metadata:', 'attachment_metadata' in MailRecordDetailSerializer().fields)
"
```
Expected: Both print True.
  </verify>
  <done>
MailRecordListSerializer has `attachment_metadata` SerializerMethodField that calls `obj.get_attachment_metadata()`. MailRecordDetailSerializer has the same field. Both serializers include the field in their output. The 'Other' special-case validation is removed from MailRecordCreateSerializer.validate().
  </done>
</task>

<task type="auto">
  <name>Task 2: Allow all roles to create mails with subsection scoping</name>
  <files>backend/records/views.py</files>
  <action>
Update the `create()` method in `MailRecordViewSet` in `backend/records/views.py`.

**Current behavior:** A hardcoded check `if user.role != 'AG': return 403` blocks all non-AG creation.

**New behavior:** Remove the AG-only guard. Add role-based scoping logic that determines what section/subsection the new mail belongs to and what users are eligible for assignment.

Replace the current create() logic with:

```python
def create(self, request, *args, **kwargs):
    """Create new mail record — all roles can create, scoped to their subsection"""
    serializer = self.get_serializer(data=request.data, context={'request': request})
    serializer.is_valid(raise_exception=True)

    user = request.user

    # Get assigned user IDs (now it's a list) - validation already done in serializer
    assigned_to_ids = serializer.validated_data.pop('assigned_to')
    initial_instructions = serializer.validated_data.get('initial_instructions', '')

    # Get assignees preserving user-selected order
    assignee_map = {
        u.id: u for u in User.objects.filter(id__in=assigned_to_ids, is_active=True)
    }
    assignees = [assignee_map[user_id] for user_id in assigned_to_ids if user_id in assignee_map]

    if not assignees:
        return Response(
            {'error': 'No valid assignees selected.'},
            status=status.HTTP_400_BAD_REQUEST
        )

    primary_assignee = assignees[0]
    monitoring_officer = primary_assignee.get_dag()

    # Determine section and subsection based on creator's role
    section_id = serializer.validated_data.pop('section', None)
    section = None

    if user.role == 'AG':
        # AG: section from serializer (may be inferred or null for cross-section)
        if section_id:
            try:
                section = Section.objects.get(id=section_id)
            except Section.DoesNotExist:
                pass
    elif user.role == 'DAG':
        # DAG: section from serializer or inferred from first managed section
        if section_id:
            try:
                section = Section.objects.get(id=section_id)
            except Section.DoesNotExist:
                pass
        if not section:
            # Use first managed section as default
            section = user.sections.first()
    elif user.role in ['SrAO', 'AAO', 'clerk']:
        # These roles: scoped to their own subsection's section
        if user.subsection:
            section = user.subsection.section
            # Override: force subsection to creator's subsection
            serializer.validated_data['subsection'] = user.subsection
        else:
            return Response(
                {'error': 'Your account has no subsection assigned. Contact an administrator.'},
                status=status.HTTP_403_FORBIDDEN
            )
    elif user.role == 'auditor':
        # Auditor: scoped to their first configured subsection
        first_sub = user.auditor_subsections.select_related('section').first()
        if not first_sub:
            return Response(
                {'error': 'Your auditor account has no subsections configured. Contact an administrator.'},
                status=status.HTTP_403_FORBIDDEN
            )
        section = first_sub.section
        serializer.validated_data['subsection'] = first_sub
    else:
        return Response(
            {'error': 'Your role is not permitted to create mail records.'},
            status=status.HTTP_403_FORBIDDEN
        )

    # Create the mail record
    mail_record = serializer.save(
        created_by=user,
        assigned_to=primary_assignee,
        current_handler=primary_assignee,
        monitoring_officer=monitoring_officer,
        section=section,
        status='Assigned',
        is_multi_assigned=(len(assignees) > 1),
        initial_instructions=initial_instructions,
        last_status_change=timezone.now()
    )

    # Create assignment records for each assignee
    for assignee in assignees:
        MailAssignment.objects.create(
            mail_record=mail_record,
            assigned_to=assignee,
            assigned_by=user,
            assignment_remarks=initial_instructions,
            status='Active'
        )

    # Audit trail for creation
    AuditTrail.objects.create(
        mail_record=mail_record,
        action='CREATE',
        performed_by=user,
        new_value={'sl_no': mail_record.sl_no, 'status': 'Assigned'},
        remarks=f'Created with initial instructions: {initial_instructions[:100]}'
    )

    # Audit trail for assignment
    assignee_names = [a.full_name for a in assignees]
    action_type = 'MULTI_ASSIGN' if len(assignees) > 1 else 'ASSIGN'
    AuditTrail.objects.create(
        mail_record=mail_record,
        action=action_type,
        performed_by=user,
        new_value={'assigned_to': assignee_names},
        remarks=f"Assigned to {len(assignees)} officer(s): {', '.join(assignee_names)}"
    )

    response_serializer = MailRecordDetailSerializer(mail_record, context={'request': request})
    return Response(response_serializer.data, status=status.HTTP_201_CREATED)
```

**MailRecordCreateSerializer validation scoping (in serializers.py — update validate()):**

The existing `validate()` method only runs the full section-inference logic for AG users. Update it to also handle non-AG creators, skipping validation that does not apply (e.g., DAG section inference) and adding subsection scope validation for lower roles:

In the `validate()` method, the section validation block starts with `if user.is_ag():`. Add an `elif` block for DAG:
```python
elif user.is_dag():
    # DAG: validate selected section is one they manage
    if selected_section is not None:
        if not user.sections.filter(id=selected_section).exists():
            raise serializers.ValidationError({
                'section': 'You can only create mails for sections you manage.'
            })
        data['section'] = selected_section
    else:
        data['section'] = None  # Will be resolved in view
```

For SrAO/AAO/clerk/auditor: skip section validation entirely in the serializer (section is forced in the view):
```python
else:
    # Subsection-scoped roles: section is determined by the view based on creator's subsection
    # No section validation needed here
    pass
```

Additionally, validate that assignees are within the creator's scope for non-AG roles. Add after the existing `if user.is_ag():` block:
```python
elif user.role in ['SrAO', 'AAO', 'clerk']:
    # Assignees must be in same subsection as creator
    if user.subsection_id:
        for assignee in assignees:
            if assignee.subsection_id != user.subsection_id:
                raise serializers.ValidationError({
                    'assigned_to': f'{assignee.full_name} is not in your subsection.'
                })
elif user.role == 'auditor':
    # Assignees must be in one of auditor's configured subsections
    auditor_sub_ids = set(user.auditor_subsections.values_list('id', flat=True))
    for assignee in assignees:
        if assignee.subsection_id not in auditor_sub_ids:
            raise serializers.ValidationError({
                'assigned_to': f'{assignee.full_name} is not in your configured subsections.'
            })
```
  </action>
  <verify>
```bash
cd D:/Office/2026/Mail_Tracker/backend && python manage.py check && python -c "
import django; django.setup()
from records.views import MailRecordViewSet
src = open('records/views.py').read()
print('SrAO/AAO in create:', 'SrAO.*AAO.*clerk' in src or ('SrAO' in src and 'clerk' in src and 'subsection' in src))
print('Auditor in create:', 'auditor' in src and 'auditor_subsections' in src)
print('AG only guard removed:', 'Only Accountant General can create' not in src)
"
```
Expected: First two True, third True (the old 403 string is gone).
  </verify>
  <done>
create() allows AG, DAG, SrAO, AAO, clerk, auditor to create mails. Each role's section/subsection is scoped correctly. Unknown roles get 403. Assignee validation in serializer scopes to creator's subsection for non-AG/DAG roles. The old 'Only Accountant General can create mail records.' error message no longer appears.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update UserMinimalSerializer and UserSerializer for new roles</name>
  <files>backend/users/serializers.py</files>
  <action>
Update `backend/users/serializers.py` to handle auditor and clerk roles in display logic.

**UserMinimalSerializer.get_sections_display():**

The current method has:
```python
if obj.role == 'DAG':
    return sections
elif obj.subsection:
    return obj.subsection.section.name
return '-'
```

Update to handle auditor:
```python
def get_sections_display(self, obj):
    if obj.role == 'DAG':
        return ', '.join([s.name for s in obj.sections.all()]) or '-'
    elif obj.role == 'auditor':
        # Show configured subsections for auditor
        subs = list(obj.auditor_subsections.select_related('section').all())
        if subs:
            return ', '.join([f"{s.section.name}/{s.name}" for s in subs])
        return '-'
    elif obj.subsection:
        return obj.subsection.section.name
    return '-'
```

**UserSerializer.get_sections_list():**

Update similarly to show subsection names for auditor:
```python
def get_sections_list(self, obj):
    if obj.role == 'DAG':
        return [{'id': s.id, 'name': s.name} for s in obj.sections.all()]
    elif obj.role == 'auditor':
        return [
            {'id': s.section.id, 'name': f"{s.section.name} / {s.name}"}
            for s in obj.auditor_subsections.select_related('section').all()
        ]
    elif obj.subsection:
        return [{'id': obj.subsection.section.id, 'name': obj.subsection.section.name}]
    return []
```

**UserCreateSerializer — add auditor_subsections field:**

Add auditor_subsections as an optional M2M field to UserCreateSerializer:
```python
auditor_subsections = serializers.PrimaryKeyRelatedField(
    many=True,
    queryset=Subsection.objects.all(),
    required=False
)
```

Add 'auditor_subsections' to Meta.fields list.

Update the `create()` method to handle auditor_subsections:
```python
def create(self, validated_data):
    password = validated_data.pop('password')
    sections = validated_data.pop('sections', [])
    auditor_subsections = validated_data.pop('auditor_subsections', [])
    ...
    user.save()
    if auditor_subsections:
        user.auditor_subsections.set(auditor_subsections)
    return user
```

Add the import at the top of the file:
```python
from sections.models import Subsection
```

**UserSerializer — expose auditor_subsections field:**

Add to UserSerializer.Meta.fields: `'auditor_subsections'`

This allows the login response and /users/me/ endpoint to return auditor_subsections so the frontend can know what subsections an auditor can access.
  </action>
  <verify>
```bash
cd D:/Office/2026/Mail_Tracker/backend && python -c "
import django; django.setup()
from users.serializers import UserSerializer, UserMinimalSerializer, UserCreateSerializer
print('UserSerializer fields:', 'auditor_subsections' in UserSerializer().fields)
print('UserCreateSerializer fields:', 'auditor_subsections' in UserCreateSerializer().fields)
print('UserMinimalSerializer OK:', 'auditor' in open('users/serializers.py').read())
" && python manage.py check
```
Expected: First two True, 'auditor' found in file, check exits 0.
  </verify>
  <done>
UserSerializer includes auditor_subsections field. UserCreateSerializer supports auditor_subsections in create(). UserMinimalSerializer.get_sections_display() handles auditor role showing subsection names. UserSerializer.get_sections_list() shows auditor subsections. Subsection import added to serializers.py.
  </done>
</task>

</tasks>

<verification>
```bash
cd D:/Office/2026/Mail_Tracker/backend
python manage.py check

# Test serializer fields
python -c "
import django; django.setup()
from records.serializers import MailRecordListSerializer, MailRecordDetailSerializer, MailRecordCreateSerializer
print('List attachment_metadata:', 'attachment_metadata' in MailRecordListSerializer().fields)
print('Detail attachment_metadata:', 'attachment_metadata' in MailRecordDetailSerializer().fields)

from users.serializers import UserSerializer, UserCreateSerializer
print('UserSerializer auditor_subsections:', 'auditor_subsections' in UserSerializer().fields)
print('UserCreateSerializer auditor_subsections:', 'auditor_subsections' in UserCreateSerializer().fields)

# Verify old AG-only guard is gone
src = open('records/views.py').read()
print('Old AG-only guard removed:', 'Only Accountant General can create mail records.' not in src)
"
```

Expected: All checks print True.
</verification>

<success_criteria>
- MailRecordListSerializer includes attachment_metadata field
- MailRecordDetailSerializer includes attachment_metadata field
- create() view allows SrAO, AAO, clerk, auditor to create mails
- create() scopes section/subsection to creator's assigned subsection for non-AG/DAG roles
- Assignee validation in serializer limits assignees to creator's subsection scope
- UserSerializer exposes auditor_subsections
- UserCreateSerializer accepts auditor_subsections in creation payload
- python manage.py check exits 0
</success_criteria>

<output>
After completion, create `.planning/phases/02-role-system-backend-updates/02-03-SUMMARY.md`
</output>
