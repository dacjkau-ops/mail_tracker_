---
phase: 02-role-system-backend-updates
plan: "02"
type: execute
wave: 2
depends_on:
  - "02-01"
files_modified:
  - backend/config/permissions.py
  - backend/records/views.py
autonomous: true
requirements:
  - ROLE-03
  - ROLE-04
  - ROLE-05
  - ROLE-06
  - ROLE-08
  - BACKEND-01
  - BACKEND-02

must_haves:
  truths:
    - "AG sees all mail records (unchanged)"
    - "DAG sees all mails in all subsections of their managed sections"
    - "SrAO/AAO see all mails within their own subsection (not just assigned-to-them)"
    - "Clerk sees only mails assigned to them OR created by them"
    - "Auditor sees only mails in their configured auditor_subsections"
    - "Auditor can reassign only to SrAO/AAO (not DAG or AG)"
    - "Permission checks enforce new role hierarchy at object level"
  artifacts:
    - path: "backend/config/permissions.py"
      provides: "Updated MailRecordPermission with new role gates"
      contains: "auditor.*clerk|clerk.*auditor"
    - path: "backend/records/views.py"
      provides: "Updated get_queryset() visibility per new rules"
      contains: "auditor_subsections|created_by.*clerk"
  key_links:
    - from: "backend/records/views.py get_queryset()"
      to: "MailRecord queryset filter per role"
      via: "user.role branching"
      pattern: "role.*auditor|auditor.*subsection"
    - from: "backend/config/permissions.py _can_view_mail()"
      to: "auditor/clerk visibility check"
      via: "user.role branching"
      pattern: "_can_view_mail.*auditor|auditor.*_can_view"
    - from: "backend/records/views.py reassign_assignment"
      to: "auditor superior check"
      via: "role restriction on reassign target"
      pattern: "auditor.*SrAO.*AAO|SrAO.*AAO.*auditor"
---

<objective>
Update permission classes and list-endpoint queryset filtering to enforce the new visibility hierarchy: DAG sees all subsection mails in their section, SrAO/AAO see subsection-level mails, clerk sees only personal mails, auditor sees configured-subsection mails. Auditor reassignment is restricted to SrAO/AAO only.

Purpose: Phase 2's core behavioral change — the new roles from Plan 01 need to be wired into the authorization and data-filtering logic. Without this, new role accounts would either see nothing or get 403s.
Output: Updated MailRecordPermission and get_queryset() in MailRecordViewSet.
</objective>

<execution_context>
@C:/Users/vaish/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/vaish/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-role-system-backend-updates/02-01-SUMMARY.md
@backend/config/permissions.py
@backend/records/views.py
@backend/users/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update MailRecordPermission for new role hierarchy</name>
  <files>backend/config/permissions.py</files>
  <action>
Rewrite `backend/config/permissions.py` to handle all six roles. Keep existing AG/DAG/SrAO/AAO logic intact where it still applies — extend for auditor and clerk.

**has_permission() changes:**

The `create` action currently blocks everyone except AG. Per ROLE-07 (handled in Plan 03), all roles will be able to create — but that logic lives in the view, not here. Update `has_permission()` for `create` to allow all authenticated users through (the view will enforce scoping):
```python
# All authenticated users can create (view enforces scoping)
if view.action == 'create':
    return True
```

Keep all other `has_permission()` actions unchanged.

**_can_view_mail() changes:**

Replace the full method body with extended role handling. Keep the existing AG/DAG/SrAO/AAO logic exactly as it is, and add new branches for auditor and clerk after the SrAO/AAO block:

```python
def _can_view_mail(self, user, obj, request):
    """Helper: check if user can view this mail record"""
    # AG: full access (handled above in has_object_permission)
    if user.role == 'DAG':
        # ... (keep existing DAG logic unchanged) ...

    if user.role in ['SrAO', 'AAO']:
        # EXPANDED from 'only assigned to them' to 'subsection-level'
        # Check if mail belongs to user's subsection
        if user.subsection_id and obj.subsection_id == user.subsection_id:
            return True
        # Check if mail's subsection is in user's subsection (via section)
        if user.subsection_id and obj.section_id == user.subsection.section_id and obj.subsection_id is None:
            return True
        # Original fallbacks: direct assignment or touched
        if obj.current_handler == user or obj.assigned_to == user:
            return True
        from records.models import MailAssignment
        if MailAssignment.objects.filter(
            mail_record=obj, assigned_to=user, status='Active'
        ).exists():
            return True
        touched_ids = getattr(request, '_touched_record_ids_cache', None)
        if touched_ids is None:
            from audit.models import AuditTrail
            touched_ids = set(AuditTrail.objects.filter(
                performed_by=user
            ).values_list('mail_record_id', flat=True))
            request._touched_record_ids_cache = touched_ids
        return obj.id in touched_ids

    # Clerk: narrow — only mails assigned to them or created by them
    if user.role == 'clerk':
        if obj.current_handler == user or obj.assigned_to == user:
            return True
        if obj.created_by_id == user.id:
            return True
        from records.models import MailAssignment
        if MailAssignment.objects.filter(
            mail_record=obj, assigned_to=user, status='Active'
        ).exists():
            return True
        return False

    # Auditor: only mails in their configured auditor_subsections
    if user.role == 'auditor':
        auditor_sub_ids = set(user.auditor_subsections.values_list('id', flat=True))
        if not auditor_sub_ids:
            return False
        if obj.subsection_id and obj.subsection_id in auditor_sub_ids:
            return True
        # Also allow if mail is in a section that contains any of their subsections
        # but mail has no subsection set — use section-level match
        if obj.section_id:
            from sections.models import Subsection
            if Subsection.objects.filter(
                id__in=auditor_sub_ids, section_id=obj.section_id
            ).exists() and obj.subsection_id is None:
                return True
        return False

    return False
```

**has_object_permission() changes:**

Add handling for new roles. The existing code has explicit cases for retrieve, update, close, reassign, multi_assign, reopen, and PDF actions. Add after the existing SrAO/AAO upload_pdf block:

For `upload_pdf` action — add auditor and clerk handling:
```python
if view.action == 'upload_pdf':
    if user.role == 'DAG':
        return self._is_dag_for_section(user, obj)
    if user.role in ['SrAO', 'AAO']:
        return obj.current_handler == user
    if user.role in ['auditor', 'clerk']:
        return obj.current_handler == user
    return False
```

For `close` action — auditor can close mails they're handling:
The existing logic already checks `obj.current_handler == user`, which covers auditor/clerk by default. No change needed.

For `reassign` action — auditor must be restricted to SrAO/AAO only (enforced in view layer in Task 2). The permission class just checks object-level canary:
```python
if view.action == 'reassign':
    if self._is_dag_for_section(user, obj):
        return True
    # Auditor can reassign only if current handler (target restriction in view)
    if user.role == 'auditor':
        return obj.current_handler == user
    return obj.current_handler == user
```

For `update` and `partial_update` — current_handler check already covers all roles. No change.

For `_is_dag_for_section` helper — no change.
  </action>
  <verify>
```bash
cd D:/Office/2026/Mail_Tracker/backend && python manage.py check && python -c "
import django; django.setup()
from config.permissions import MailRecordPermission
p = MailRecordPermission()
print('MailRecordPermission loaded OK')
print('_can_view_mail has clerk:', 'clerk' in open('config/permissions.py').read())
print('_can_view_mail has auditor:', 'auditor' in open('config/permissions.py').read())
"
```
Expected: MailRecordPermission loads without ImportError, 'clerk' and 'auditor' strings present in file.
  </verify>
  <done>
MailRecordPermission._can_view_mail() handles all 6 roles. `create` action in has_permission() allows all authenticated users. Auditor visibility limited to auditor_subsections. Clerk visibility limited to assigned/created-by. SrAO/AAO visibility expanded to subsection-level. upload_pdf allows auditor/clerk as current_handler.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update get_queryset() and reassign view for new visibility rules</name>
  <files>backend/records/views.py</files>
  <action>
Update `MailRecordViewSet.get_queryset()` and the `reassign` action in `backend/records/views.py`.

**get_queryset() — replace the role-branching section:**

The existing code has three branches: AG (no filter), DAG, and `else` (SrAO/AAO). Replace the `else` branch with explicit handling for all remaining roles:

```python
def get_queryset(self):
    user = self.request.user
    queryset = MailRecord.objects.select_related(
        'assigned_to', 'current_handler', 'monitoring_officer',
        'section', 'subsection', 'subsection__section', 'created_by'
    )
    if self.action == 'list':
        queryset = queryset.prefetch_related(
            'parallel_assignments__assigned_to',
            'parallel_assignments__reassigned_to'
        )

    # AG: see all records (unchanged)
    if user.role == 'AG':
        pass

    # DAG: all mails in all subsections of their managed sections
    # (unchanged — existing logic already includes cross-section visibility)
    elif user.role == 'DAG':
        # ... keep existing DAG block exactly as-is ...

    # SrAO/AAO: all mails in their own subsection (EXPANDED from assigned-only)
    elif user.role in ['SrAO', 'AAO']:
        touched_record_ids = AuditTrail.objects.filter(
            performed_by=user
        ).values_list('mail_record_id', flat=True).distinct()

        assigned_via_parallel = MailAssignment.objects.filter(
            assigned_to=user,
            status='Active'
        ).values_list('mail_record_id', flat=True).distinct()

        queryset = queryset.filter(
            Q(current_handler=user) |
            Q(assigned_to=user) |
            Q(subsection=user.subsection) |        # All mails in user's subsection
            Q(id__in=touched_record_ids) |
            Q(id__in=assigned_via_parallel)
        )

    # Clerk: only mails assigned to them OR created by them
    elif user.role == 'clerk':
        assigned_via_parallel = MailAssignment.objects.filter(
            assigned_to=user,
            status='Active'
        ).values_list('mail_record_id', flat=True).distinct()

        queryset = queryset.filter(
            Q(current_handler=user) |
            Q(assigned_to=user) |
            Q(created_by=user) |
            Q(id__in=assigned_via_parallel)
        )

    # Auditor: only mails in their configured auditor_subsections
    elif user.role == 'auditor':
        auditor_sub_ids = list(user.auditor_subsections.values_list('id', flat=True))
        if not auditor_sub_ids:
            queryset = queryset.none()
        else:
            queryset = queryset.filter(
                Q(subsection__in=auditor_sub_ids) |
                # Include section-level mails (no subsection set) where any configured subsection exists
                Q(subsection__isnull=True, section__subsections__id__in=auditor_sub_ids)
            ).distinct()

    else:
        # Fallback: no access for unknown roles
        queryset = queryset.none()

    # Apply filters (keep existing filter block unchanged)
    ...
```

Preserve the existing DAG block exactly as written (it already correctly handles subsection-level visibility via cross-section mail IDs).

**reassign view — add auditor target restriction:**

In the `reassign()` action method, after the existing permission check block (after `allowed_candidates` check), add a specific guard for auditor users:

```python
# Auditor can only reassign to SrAO/AAO (immediate superior only)
if user.role == 'auditor':
    if new_handler.role not in ['SrAO', 'AAO']:
        return Response(
            {'error': 'Auditors can only reassign to SrAO or AAO officers.'},
            status=status.HTTP_403_FORBIDDEN
        )
```

Place this check BEFORE the `old_handler = mail_record.current_handler` line and AFTER the `allowed_candidates.filter(id=new_handler.id).exists()` check.

**_get_reassign_candidates_queryset() — add auditor and clerk branches:**

Add after the existing SrAO/AAO block:
```python
# Auditor: can only escalate to SrAO/AAO in their configured subsections
if user.role == 'auditor':
    auditor_sub_ids = list(user.auditor_subsections.values_list('id', flat=True))
    return candidates.filter(
        role__in=['SrAO', 'AAO'],
        subsection__in=auditor_sub_ids
    ).distinct()

# Clerk: same subsection as themselves (mirrors SrAO/AAO pattern)
if user.role == 'clerk':
    if not user.subsection_id:
        return User.objects.none()
    return candidates.filter(subsection_id=user.subsection_id).distinct()
```

The `return User.objects.none()` at the end of the method acts as the default fallback.
  </action>
  <verify>
```bash
cd D:/Office/2026/Mail_Tracker/backend && python manage.py check && python -c "
import django; django.setup()
from records.views import MailRecordViewSet
v = MailRecordViewSet()
print('ViewSet loaded OK')
src = open('records/views.py').read()
print('Has clerk branch:', 'clerk' in src)
print('Has auditor branch:', 'auditor' in src)
print('Has subsection filter:', 'subsection=user.subsection' in src or 'subsection__in=auditor' in src)
"
```
Expected: ViewSet loads OK, clerk/auditor branches present, subsection filter present.
  </verify>
  <done>
MailRecordViewSet.get_queryset() has distinct branches for SrAO/AAO (subsection-level), clerk (personal mails), and auditor (configured subsections). `_get_reassign_candidates_queryset()` handles auditor (SrAO/AAO only) and clerk (same subsection). `reassign()` view enforces auditor-to-SrAO/AAO-only restriction with a 403. python manage.py check exits 0.
  </done>
</task>

</tasks>

<verification>
```bash
cd D:/Office/2026/Mail_Tracker/backend
python manage.py check

# Verify role strings appear in both files
python -c "
perm = open('config/permissions.py').read()
view = open('records/views.py').read()
for role in ['auditor', 'clerk']:
    print(f'{role} in permissions:', role in perm)
    print(f'{role} in views:', role in view)
print('auditor_subsections in views:', 'auditor_subsections' in view)
print('Auditor SrAO restriction in views:', \"role not in ['SrAO', 'AAO']\" in view or 'SrAO.*AAO' in view)
"
```

Expected: All six checks print True.
</verification>

<success_criteria>
- AG sees all mails (unchanged)
- DAG sees all mails in their managed sections (unchanged, already correct)
- SrAO/AAO get_queryset includes Q(subsection=user.subsection) filter
- Clerk get_queryset filters to current_handler, assigned_to, created_by
- Auditor get_queryset filters to auditor_subsections
- Auditor reassign view returns 403 if target role is not SrAO/AAO
- _get_reassign_candidates_queryset handles auditor and clerk
- python manage.py check exits 0
</success_criteria>

<output>
After completion, create `.planning/phases/02-role-system-backend-updates/02-02-SUMMARY.md`
</output>
